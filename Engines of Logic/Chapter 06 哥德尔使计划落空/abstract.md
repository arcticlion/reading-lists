哥德尔使计划落空
===============

与弗雷格和康托尔对实证主义的局限性的不满相呼应，哥德尔承认，正是通过拒斥那些思想，他才有可能看到被其他逻辑学家所忽略的联系，并且做出那些伟大的发现。

### 有效推理

罗素所阐述的全部的数学都可以用一个形式逻辑系统来表示，以及其学生维特根斯坦所强调的在语言内言说语言的问题，影响了年轻的哥德尔的研究方向。维特根斯坦所关注的这些东西与希尔伯特的立场相当一致，他们都认为形式逻辑系统不仅可以在系统内部表达数学推理，而且还可以从系统外部用数学方法加以研究。

在希尔伯特在哥廷根所教授的逻辑课程中，他所采用的逻辑演绎的基本规则源自费雷格的《概念文字》以及怀特海与罗素合著的《数学原理》。在他1928年的逻辑教科书中，希尔伯特提出了在这些规则之间是否存在间隙的问题，也就是说，演绎推理应当是正确的，但规则本身却并不足以保证从前提能够得出结论。他相信并不存在这样的间隙，但他要求对规则本身是**完备**的进行证明。哥德尔选择了这个问题作博士论文。他很快就得到了希尔伯特所想要的结果，并且所运用的技巧是当时的逻辑学家们相当熟悉的。

演绎逻辑是从前提到结论的过程。当我们使用弗雷格－罗素－希尔伯特的符号逻辑时，每一个前提和结论皆由一个逻辑公式表示，也就是相当于一个符号串。这些符号中有些表示纯粹的逻辑概念，有些只是标点符号，还有一些是指相关的特定主题。下面是一个逻辑推理的理智：其中前两行是前提，第三行则是结论。

```
任何一个恋爱中的人都是快乐的。
威廉爱着苏珊
------------------------------
威廉是快乐的
```

运用第三章所介绍的逻辑符号系统，我们可以把它翻译成逻辑语言：

```
（∀x）（（∃y）L（x，y）⊃H（x））（*）
L（W，S）
------------------------------------
H（W）
```

在这个推理中所使用的逻辑符号是⊃，∀和∃，其含义见下表：

```
⊃如果……，那么……
∀所有
∃某个
```

字母x，y是**变元**,它们（就像代词一样）表示被考察人群中的任一个体，而其他符号L，W，H和S所具有的含义则与特定的主题相关。如下所示：

```
L＝恋爱关系
H＝快乐这一属性
W＝威廉
S＝苏珊
```

由此我们可以把这一推理表示成如下形式：

```
对于所有s，如果有一个y为x所爱，则x是快乐的。
威廉爱着苏珊
-----------------------------------------
威廉是快乐的。
```

说这个推理是有效的就意味着，无论我们所选择的这些个体所处的群体是什么，无论用字母L表示这些个体间的什么关系，无论用字母H表示这些个体所具有的什么属性，以及无论选择把哪些特定的个体指定给字母W和S，只要我们在推理时保证两个前提皆为真陈述，那么结论就必然为真。为了进一步阐明什么叫做一个推理是**有效**的，我们不妨用一种完全不同的主题对前面的符号推理做出解释：

```
肉食动物有着锋利的牙齿。
狼捕食羊。
----------------------
狼有着锋利的牙齿。
```

为了说明这个例子也可以用前面的符号推理(`*`)来表示，我们可以用变元x，y来表示哺乳动物的任意种类，并对其他字母作如下解释：

```
L＝物种之间的捕食关系
H＝有锋利牙齿这一属性
W＝狼
S＝羊
```

于是，这一符号推理就可以表示为：

```
对于所有的x，如果有一个y是被x捕食的，则x有锋利的牙齿。
狼捕食羊
-----------------------------------------------------
狼有锋利的牙齿。
```

以上解释了推理是有效的是什么含义。希尔伯特希望证明，任何一个有效的推理都可以用弗雷格－罗素－希尔伯特的规则从前提到结论逐步得到证明。换句话说，希尔伯特期望这样一种证明：如果一个推理具有如下属性，

```
无论对公式中的字母作何种解释，只要其前提是真陈述，则它的结论就是真的。
```

那么我们就可以用弗雷格－罗素－希尔伯特的规则从前提推演出结论。哥德尔在其博士论文中成功地给出了希尔伯特所期望的证明。

### 皮亚诺算术

PM系统过于复杂，我们在这里难以详述。故此，我们用较为简单的系统PA来显示在构造不可判定命题时所涉及的一些因素。PA可以用16个符号建立起来：

```
⊃ ¬ ∨ ∧ ∀ ∃ 1 ＋x X y z ( ) ` =
```

符号1，＋，X，＝是为了强调它们将仅仅被视为符号，同时也暗示它们原有的含义。字母x，y，z是表示自然数的变元，由于所需要的变元不只3个，所以我们可以把符号'加在那些字母上方，从而可以产生出任意多个变元。于是，y'和z'''都是变元。由于这里的符号超过了10个，我们将使用一种编码表，其中每一个符号都被一对十进制数字所替代：

```
⊃  ¬  ∨  ∧  ∀  ∃  1  ＋ X  x  y  z  (  )  `  =
↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
10 11 12 13 14 15 21 22 23 31 32 33 41 42 43 44
```

自然数本身又被特定的字符串所表示，这些字符串被称为数字符号（numerals），如下所示：

| 数字符号      | 被表示的数 | 代码                       |
| --------      | ---------  | -----                      |
| 1             | 1          | 21                         |
| (1+1)         | 2          | 4121222142                 |
| ((1+1)+1)     | 3          | 4141212221422222142        |
| (((1+1)+1)+1) | 4          | 41414121222142222142222142 |
| ...           | ...        | ...                        |

某些被称为句子的字符串可以被用来表示关于自然数的真假命题。于是，字符串

```
((1+1)X(1+1)=(((1+1)+1)+1))
```

的代码是

```
414121222142234121222142444141412122214222214222214242
```

它表示真命题2乘2等于4.而

```
((1+1)X(1+1) = ((1+1) + 1))
```

则表示假命题2乘2等于3.句子

```
(∀x)(¬(x=1)⊃(∃y)(x=(y+1)))
```

的代码是

```
4114314241114131442142104115324241314441322221424242
```

它表示除1以外的所有自然数都有前趋。

为了完成我们对PA的描述，有必要把某些特定的句子指定为公理和用于从公理推出可证句子的推理规则。从公理开始，到PA中的一个可证句子结束，其间的整个步骤被称为该句子的证明。虽然仔仔细细做完此事会把我们带得太远，但哦我们还是考虑一个简单得例子：

```
(∀x)¬(1=(x+1))
```

它表示这样一个命题：1不是任何自然数得直接后继。这个句子完全可以被选为一条公理。既然句子开头得符号∀表示某种属性对于所有自然数都适用，那么一条自然的推理规则就是，允许用一些数字符号来替换x（除去全程量词（∀x）之后）。这只是从一个普遍陈述推出它的一个特殊情形。下面是一个简单的例子：

```
(∀x)¬(1=(x+1))
--------------
¬(1=(1+1))
```

该结论是PA中的一个可证句子，它是通过用1替换变元x而得到的，它表示1和2是不等的这一事实。

除了用来表示命题的字符串外，还有其他一些被称为一元字符串，它们可以被用来定义自然数的集合。这些字符串将包含符号x，但不包含“量词”（∀x）或（∃x）（虽然它可以包含像y或x^n这样的关于其他变元的量词）。此外，一元字符串有一种至关重要的性质：假如所有x都被某个数字符号所代替，那么由此得到的字符串将是一个句子。一下是一元字符串的一个例子：

```
(∃y)(x=((1+1)Xy))
```

它的代码是

```
4115324241314441412122214223324242
```

假如x被数学符号（1+1）所替代，则我们就得到了真句子

```
(∃y)((1+1) = ((1+1)Xy))
```

假如x被数学符号1所代替，我们就得到了假句子

```
(∃y)(1 = ((1+1)Xy))
```

可以认为这个一元字符串为偶数集提供了一种定义。一下是一个更为复杂的一元字符串：

```
(∀y)(∀z)((x = (yXz))⊃((y=1)∨(y=x)))
```

它的代码是

```
41143242411433424241314441322333424210414132441421241324431424242
```

它定义了由1和全部质数所组成的集合。

给定一个一元字符串A和自然数n，我们将用符号［A：n］来表示用**表示数字n的数字符号来替换A中的x所得到的句子**.例如：

```
[(∃y)(x=((1+1)Xy)):2]
```

表示句子

```
(∃y)((1+1)=((1+1)Xy))
```

现在，我们就可以解释如何用哥德尔的方法生成PA中的一个句子U，该句子表示U本身在PA中是不可证的这一命题。使用被分配给一元字符串的码数，我们就可以依照它们的代码大小将其全部排列起来。在这种排序中，代码最小的一元字符串是（x＝1），即使连它的代码也是`4131442142`,超过了40亿。我们用A1来表示这个一元字符串，并想象所有的一元字符串都依照它们代码的大小排成一个序列：

```
A1, A2, A3, ...
```

因为这些都是一元字符串，所以对于任意的自然数n，m，字符串［An:m]就将是一个句子。这些句子中的某一些在PA中将是可证的，另一些则是不可证的。对于每一个n，我们都可以考虑由那些使得字符串［An:m］在PA中是不可证的m所组成的集合。

回忆一下我们对康托尔的对角线方法所作的讨论，我们看到这样一个集合可以被看成一个以n为标签的包裹。运用对角线方法，也就是说，把包裹中的一个元素当作标签，我们就可以构造出一个由那些使得［An：n］在PA中不可证的n所组成的集合K。利用PA中的可证明性可以在PA中进行定义这一事实，我们就可以找到一个一元字符串B，它在PA中定义了集合K。现在必然存在着某个数q使得B＝Aq，因为所有的一元字符串都包含在As的序列中。于是，对于每一个自然数n，句子［Aq：n］都表示命题

```
[An:n]在PA中是不可证的
```

特别地，当n被赋予q值时，我们可以看到，[Aq:q]表示命题

```
[Aq:q]在PA中是不可证的
```

因此，[Aq:q]是PA中的一个句子，它表示它本身在PA中不可证这一命题。

