分析框架
=======

本节中，概要地描述一个分析算法效率的一般性框架。必须指出，有两种算法效率：时间效率和空间效率。对于大多数问题来说，在速度上能够取得的进展要远远大于空间上的进展。所以，我们把主要精力集中在时间效率上，这里的分析框架对于分析空间效率也是适用的。

### 输入规模的度量

首先考虑输入规模的度量单位，一个显而易见的事实：算法对于规模更大的输入需要运行更长的时间。所以，使用一个以算法输入规模n为参数的函数，来研究算法效率是非常合乎逻辑的。例如，对于排序，查找，寻找列表的最小元素以及其他大多数和列表打交道的问题，这个参数就是列表的长度。n次多项式P(x) = anxn + ... + a0求值的问题，参数是多项次的次数，或者是它系数的个数，系数的个数比次数大一。这样一个细小的差别对于效率分析来说是无关紧要的。

有些情况下，选择哪个参数表示输入规模是有差别的，这受到所讨论算法的操作细节的影响。我们注意选择谁人规模的合适量度。例如，对于一个拼写检查算法，如果算法对于输入的每一个独立字符都要做检查，我们使用字符的数量来度量输入规模；如果它的操作是以单词为单位，我们应该统计输入中词的数量。

### 运行时间的度量单位

接下来考虑算法运行时间的度量单位。我们不使用秒，毫秒之类的时间度量，因为它依赖于计算机硬件，编译器，同时时间运行时间计时也很困难。

我们统计算法**基本操作**的执行次数，即算法中最重要的操作。它们对总运行时间的贡献最大。

一个算法的基本操作：它通常是算法最内层循环中最费时的操作。例如，排序算法是通过比较列表总的待排序元素(键)工作的，故其基本操作就是对键的比较。

这就是一个算法时间效率的分析框架。对于输入规模为n的算法，可以统计它的基本操作执行次数，来对其效率进行度量。2.3节和2.4节分别介绍计算非递归算法和递归算法的“执行次数”。

该框架的一个重要应用。约定，Cop为一个算法基本操作的执行时间，而C(n)是该算法需要执行基本操作的次数。然后，对运行在那台计算机上的某个算法程序的运行时间，用以下公式做估计：

![](https://github.com/arcticlion/reading-lists/blob/master/Introduction%20to%20the%20Design%20and%20Analysis%20of%20Algorithms/02%20Fundamentals%20of%20the%20Analysis%20of%20Algorithm%20Efficiency/屏幕截图%202014-11-25%2013.15.24.png)

这个公式可以回答这种问题：“如果这个算法运行在一台比我们现在的机器快十倍的机器上，它运行地有多快呢？很明显答案是10倍。

或者假设C(n) = 1/2n(n-1),如果输入规模翻倍，该算法会运行多长时间呢？

![](https://github.com/arcticlion/reading-lists/blob/master/Introduction%20to%20the%20Design%20and%20Analysis%20of%20Algorithms/02%20Fundamentals%20of%20the%20Analysis%20of%20Algorithm%20Efficiency/屏幕截图%202014-11-25%2013.17.38.png)

答案是大约要运行4倍的时间。

注意，我们不需要知道Cop的值就能够回答刚才的问题：这个值在做出发的时候已经完全被约去了。还需要注意的是，C(n)公式的乘法常量1/2也被越饿去了。因此，对于大规模的输入，我们的效率分析框架忽略执行次数C(n)中的乘法常量，而仅关注执行次数的**增长次数**及其常熟倍。

