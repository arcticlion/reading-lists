穷举查找
=======

许多重要问题要求在一个复杂度随实例规模指数增长的域中，查找一个具有特定属性的元素。一般来说，这个问题的元素是指组合对象，比如排列，组合以及一个给定集合的子集。许多这样的问题都是最值问题：它们要求一个元素，能使某些期望的特性最大化或者最小化，比如路径的长度或者分配的成本。

对于组合问题来说，**穷举查找**是一种简单蛮力方法。它要求生成问题域中的每一个元素，选出其中满足问题约束的元素，然后再找出一个期望元素（例如，使目标函数达到最值元素）。穷举查找常常会要求一个算法来生成某些组合对象。我们把这种算法放到第5章去讨论，在这里，我们假设这种算法已经存在了。下面通过三个重要的应用来阐明穷举查找：旅行商问题，背包问题以及分配问题。

### 旅行商问题

旅行商问题因有着重要应用以及和其他组合问题的重要关联而很值得研究。非专业的说法，这个问题要求找出一条n个给定的城市间的最短路径，使我们从一个城市出发，对每一个城市都只访问一次。这个问题可以很方便地用加权图来建模，也就是说，用图的顶点代表城市，用边的权重表示城市间的距离。然后这个问题就可以表述为求一个图的最短**哈密顿回路**问题。（哈密顿回路定义为一个对图的每个顶点都只穿越一次的回路）。

哈密顿回路定义为n＋1个相邻顶点Vi0,...,Vin-1,Vi0的一个序列。其中，序列的第一个顶点和最后一个顶点是相同的，而其他n－1个顶点都是互不相同的。因此，通过生成n－1个中间城市的组合来得到所有旅行线路，计算这些线路的长度，然后求得最短的线路。图3.7介绍了该问题的一个小规模实例，并用该方法求出了它的解。



观察图3.7，我们有3对不同的线路，对每对线路来说，不同的只是线路的方向。因此，我们定义一条线路的方向可以把顶戴呢排列的数量减半。

然而这个改进并不能大大改善效率。排列的总次数仍然需要(n-1)!/2次，这意味着除了一些非常小的n之外，穷举查找法几乎是不实用的。

