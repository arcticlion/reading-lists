大整数乘法和Strassen矩阵乘法
============================

本节中，研究两个不同寻常的算法，它们用于解决两个数的乘法和两个方阵的乘法。两个算法都以增加少量加法运算为代价，减少乘法运算的执行总次数 。为了达到这个目的，两者都使用了分治思想。

### 大整数乘法

当代的密码技术，需要对超过100位的十进制整数进行乘法运算。因为这样的整数过于长，现代计算机的一个“字”是装不下的，所以我们需要对它们作特别的处理。这就是研究高效的大整数乘法运算的现实需求。

经典的笔算算法对两个n位整数相乘，第一个数中的n个素质分别要被第二个数中的n个数字相乘，这样就一共要做n^2次位乘。现在我们用分治法设计一个乘法次数少于n^2的算法.

为了展示该算法的基本思想，我们研究一个两位整数相乘的案例，比如说，23和14.这两个数字可以这样表示：

> 23 = 2·10^1 + 3·10^0
> 14 = 1·10^1 + 4^10^0

现在把它们相乘：

> 23 = (2·10^1 + 3·10^0) * (1·10^1 + 4·10^0)
>    = (2 * 1)10^2 + (3 * 1 +  2 * 4)10^1 + (3 * 4)10^0

方程产生出一个正确的结果322，和笔算算法一样，使用了四次位乘。

但是`2*1`和`3*4`无论如何都需要计算，我们可以利用它们的积，只做一次乘法计算出中间项的结果，来减少位乘的次数。

> 3 * 1 + 2 * 4 = (2+3) * (1+4) - (2 * 1) - (3 * 4)

总结一个规律，对于任何两位数a=a1a0和b=b1b0，它们的积c可以用这个公式来计算：

> c = a * b = c2 * 10^2 + c1 * 10^1 + c0

其中，

c2 = a1 * b1

c0 = a0 * b0

c1 = (a1+b1) * (a0+b0) - (c2+c0)，即a数字和b数字和的积减去c2与c0的和。

现在我们应用这个窍门计算两个n位整数a和b的积，其中n是一个正的偶数。我们从中间把两个数字一分为二，毕竟，要利用分治技术。把a的前半部分记住a1, a的后半部分记住a0；对于b，则分别记住b1和b0.

在这种记法中，a＝a1a0意味着`a=a1*10^(n/2) + a0`, b = b1b0意味着`b=b1*10^(n/2) + b0`.所以利用与计算两位数相同的方法，我们有：

> c = a * b = (a1 * 10^(n/2) + a0) * (b1 * 10^(n/2) + b0)
>   = (a1 * b1)10^n + (a1  * b0 + a0 * b1)10^(n/2) + (a0 * b0)
>   = c2 * 10^n + c1 * 10^(n/2) + c0

其中，

`c2 = a1*b1`是它们前半部分的积`c0 = a0*b0`,是它们后半部分的积，

`c1 = (a1+a0)*(b1+b0)-(c2+c1)`是a两部分和与b两部分和的积减去c2与c0的和。

因此，如果n是2的乘方，我们就得到了一个计算两个n位数积的递归算法。在这种完美的形式下，当n变成1时，递归就停止了。

该算法会做多少次位乘呢？

因为n位数的乘法需要对n/2位数做三次乘法运算，乘法次数M(n)的递推式将会是：

> 当n>1时，M(n) = 3M(n/2), M(1)=1

当b＝2^k时，我们用反向替换法对它求解：

> M(2^k) = 3M(2^k-1) = 3[3M(2^(k-2))] = 3^2M(2^(k-2))
>        = ...=3^iM(2^(k-i)=...=3^kM(2^(k-k))=3^k

因为k＝log2 n,

> M(n) = 3^(log2 n) = n^(log2 3) ≈ n^1.585
> (最后一步，利用了对数的一个特性：a^logb c = c^logb a

对于不是很大的整数，该算法的运行时间很可能比经典算法长。报告说，实验显示，大于600位的整数开始，分治算法的性能超越了笔算算法的性能。如果我们使用类似Java，C++和Smalltalk这样的面向对象的语言，会发现这些语言专门为处理大整数提供了一些类。

