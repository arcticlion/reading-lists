两种典型的微处理器
=================

微处理器——正是它，将计算机中央处理器的所有构成部件整合在一起，集成在一个硅芯片上——诞生于1971年。它的诞生有着很好的开端：第一个微处理器，即Intel 4004系列，包括了2300个晶体管。到现在，大约三十年过去了，家用计算机的微处理器中的晶体管数量也逐步逼近10 000 000个。

微处理器实际的作用基本上保持不变。现在的芯片上附加的上百万个晶体管可以做许多有趣的事情，但在微处理器最初的探索过程中，这些事情更多的是分散我们的注意力而不是给我们以启迪。为了对微处理器的工作情况获得更清晰的认识，让我们先看一下最初的微处理器。

### 8080微处理器

我们要讨论的微处理器出现于1974年。在该年度，Intel公司在4月推出了8080，Motorola（摩托罗拉）—从20世纪50年代开始生产半导体和晶体管产品的公司—在8月份推出了6800。它们并非是那年仅有的微处理器。同样是在1974年，德克萨斯仪器公司推出了4位的TMS1000，用在许多计算器、玩具和设备上；NationalSemiconductor（国家半导体公司）推出了PACE，它是第一个16位的微处理器。然而，回想起来，8080和6800是两个最具有重大历史意义的芯片。

Intel设定8080最初价格为$360，这是对IBMSystem/360的一个讽刺。IBMSystem/360是一个大型机系统，由许多大公司使用，要花费几百万美元。（今天，你只花$1.95就可以买到一个8080芯片。）这并不是说8080可以与System/360相提并论，但不用几年，IBM公司也将会正视这些很小的计算机。

8080是一个8位的微处理器，有6000个晶体管，时钟频率为2MHz，可寻址64KB的存储空间。6800（今天也只卖$1.95）有大约4000个晶体管，也可寻址64KB的存储空间。第1代6800的时钟频率为1MHz，但到1977年Motorola公司发布新款的6800时，其时钟频率已为1.5MHz和2MHz。

这些芯片被称为“单芯片微处理器”（single－chip microprocessors），不太准确的说法是“单芯片的计算机”。处理器只是计算机的一部分。除了处理器之外，计算机还需要其他一些设备，至少要包括一些随机访问的存储器（RAM）一些方便用户把信息输入计算机的设备（输入设备），一些使用户能够把信息从计算机中读取出来的设备（输出设备），以及其他一些能把所有构件连接在一起的芯片。本书会在第21章详细介绍这些构件。

现在，让我们来仔细研究一下微处理器本身。当描述微处理器的时候，我们总是习惯用一些框图来阐明其内部的构件及其连接情况。然而，在第17章我们已经使用了数不清的框图来描述它，现在我们将观察微处理器和外部设备的交互过程，以此来认识其内部的结构和工作原理。换句话说，为了弄清微处理器的工作原理，我们把它视作一个不需要详细研究其内部操作的黑盒。取而代之的方法是通过贯彻芯片的输入，输出型号，特别是芯片的指令集来理解微处理器的工作原理。

8080和6800都是40个管脚的集成电路。这些芯片最常见的IC封装大约为2英寸长，1/2英寸宽，1/8英寸厚。



当然，你看到的只是外包装。位于其内部的硅晶片非常小，就拿早期的8位微处理器来说，其硅晶片小于1/4平方英寸。外包装保护硅晶片并通过管脚提供对芯片的输入和输出点的访问。下图显示了8080的40个管脚的功能：



本书中我们所创建的所有电气或电子设备都需要某种电源供电。8080的一个特殊地方就是它需要三种电源电压：管教20必须接到5V的电压；管教11需要接到－5V的电压；管教28需要接到12V的电压；管脚2接地。（1976年，Intel发布了8085芯片，简化了这些电源需求）。

其他的管脚都标有箭头。从芯片引出的箭头表明这是一个输出（output）信号，这种信号由微处理器控制，计算机的其他芯片对该信号响应。指向芯片的箭头表明该信号是一个输入（input）信号，该信号由其他芯片发出，并由8080芯片对其响应。还一些管脚既是输入又是输出。

第17章所设计的处理器需要一个振荡器来使其工作。8080需要两个不同的同步时钟输入，它们的频率都是2MHz，分别标记为ø1和ø2，位于管脚22和15上。这些信号可以很方便地由Intel公司生产的8224时钟信号发生器提供。给这个芯片连上一个18MHz的石英晶体，剩下的工作它基本上可以完成。


一个微处理器通常有多个用来寻址存储器的输出信号。用于寻址的输出信号的数目与微处理器的可寻址空间大小直接相关。8080有16个用于寻址的输出信号，标记为A0～A15，因此它的可寻址空间大小为2的16次方，即65 536字节。

8080是一个8位的微处理器，可以一次从存储器读取或者向存储器写入8位数据。该芯片还包括标记为D0～D7的8个信号，这些信号是芯片仅有的几个既可以用做输入又可以用做输出的信号。当微处理器从存储器中读取一个字节时，这些管脚的功能是输入；当微处理器向存储器写入一个字节时，其功能又变成了输出。

芯片的其余10个管脚时控制信号（control signals）。例如，RESET（复位）输入用于控制微处理器的复位。输出信号1-WR的功能是指明微处理器需要向RAM中写入数据（1-WR信号对应于RAM阵列的写输入）。另外，当芯片读取指令时，其他控制信号会在某个时候出现在D0~D7管脚。由8080构成的计算机系统通常使用8228系统控制芯片来锁存这些附加的控制信号。后面将会讲述一些控制信号。由于8080的控制信号非常复杂，因此，除非你想基于8080芯片来实际设计计算机，否则最好不要用这些控制信号来折磨自己。

8080芯片复位后，它把锁存在存储器0000h地址处的字节读入微处理器，通过在地址信号端A0～A15输出16个0实现该过程。它读取的字节必须是8080指令，读取该字节的过程被称为取指令（instruction fetch）。

在第17章构造的计算机里，所有指令（除了停止指令HLT）都是3个字节长，包括一个操作码和两个字节的地址。在8080中，指令长度可以是1个字节、2个字节或3个字节。有些指令可使8080从存储器的某一位置处读出一个字节送到微处理器中；有些指令可使8080从微处理器中把数据写入存储器的某一位置处；其他指令可使8080不使用RAM而在内部执行。第一条指令执行完后，8080访问存储器中的第二条指令，依此类推。这些指令组合在一起构成一个计算机程序，用来完成一些自己感兴趣的事情。

当8080运行在最高速度即2MHz时，每个时钟周期为500纳秒（1除以2000000周等于0.000000500秒）。第17章中的每条指令都需要4个时钟周期，8080的每条指令则需要4～18个时钟周期，这意味着每条指令的执行时间为2～9微秒（即百万分之一秒）。

#### 指令集

也许了解某个特定微处理器的功能最好的办法就是全面地测试其完整的指令集。

第17章最后完成的计算机包括12个指令。一个8位处理器的指令数很容易达到256，每一条指令的操作码就是一个特定的8位数（如果某些指令包含2字节的操作码，其指令集会更大）。8080虽没有那么多，但它也有244条操作码。这看起来似乎很多，但总的来说，却又不比第17章中的计算机功能多多少。例如，如果想用8080做乘法或除法，仍然需要写一段小程序来实现。

在第17章曾经讲到过，为了方便地引用指令，我们为处理器的每一条指令的操作码都指派了一个特殊的助记符，而且其中的一些助记符是可以带有参数的。这种助记符只是在我们使用操作码提供方便，它对于处理器是没有帮助的，处理器只能读取字节，对于助记符组成的文本的含义一无所知（为了讲解清楚，本书选用了Intel 8080说明文档中用到的部分助记符为例说明）。

##### 基本指令集

第17章中的计算机有两条很重要的指令，称作装载（Load）和保存（Store）指令。这些指令都占用三个字节的存储空间。装载指令的第一个字节是操作码，操作码后的两个字节表示16位地址。处理器把在此地址中的字节送到累加器。同样，保存指令把累加器中的内容存储到指令指定的地址处。

下面，我们用助记符来简写这两个操作：

```
LOD A, [aaaa]
STO [aaaa], A
```

在此，A表示累加器（装载指令的目的操作数，保存指令的源操作数），aaaa表示一个16位的存储器地址，通常用4位十六进制数来表示。

同第17章的累加器一样，8080的8位累加器也记做A。正如第17章中的计算机一样，8080也有两条与装载和保存指令功能一样的指令。8080中这两条指令的操作码为32h和3Ah，每个操作码后有一个16位地址。8080的助记符为STA（代表存储累加器的内容）和LDA（代表装载到累加器）：

| 操作码 | 指 令        |
| ------ | -----        |
| 32     | STA [aaaa],A |
| 3A     | LDA A,[aaaa] |

8080芯片的微处理器的内部除累加器外还设置了6个寄存器（register），每个寄存器可以存放一个8位的数。这些寄存器和累加器非常相似，实际上累加器被视为一种特殊的寄存器。这6个寄存器和累加器一样，本质上都是锁存器。处理器既可以把数据从存储器读入寄存器，也可以把数据从寄存器存回存储器。当然，其他的寄存器没有累加器所具有的丰富的功能，例如，当把两个8位数相加时，其结果总是保存到累加器而不会保存到其他寄存器。

在8080中用B，C，D，E，H和L来表示新增的6个寄存器。为什么用H和L呢？因为使用H和L来命名寄存器是因为它们具有特殊的含义，H可以代表高（High）而L可以代表低（Low）。通常把两个8位寄存器H和L合起来构成一个16位存储器对（register pair），称作HL，H用来保存高字节而L用来保存低字节。这个16位的值通常用来对存储器寻址，我们将在下面看到它是怎样以简单的方式工作的。

寄存器是计算机必不可少的部件吗？为什么第17章搭建的计算机中并没有寄存器的踪迹？从理论上讲，这些寄存器不是必需的，在第17章也没有用到它们，但是实际应用中使用它们将带来很大的方便。很多计算机程序都同时用到多个数据，将这些数据存放在寄存器比存放在存储器更便于访问，因为程序访问内存的次数越少其执行速度就越快。

在8080中有一个指令至少用到了63个操作码，这条指令就是MOV，即Move的缩写，其实该指令是一条单字节指令，它主要用来把一个寄存器中的内容转移到另一个寄存器（也可能就是原来的寄存器）。因为8080微处理器设计了7个寄存器（包括累加器在内），因此应用中使用大量的MOV指令是很正常的。

下面列出了前32条MOV指令。再一次提醒你，两个参数中左侧的是目标操作数，右侧的是源操作数。

| 操作码    | 指令       | 操作码      | 指令       |
| --------- | ---------- | ----------- | ----       |
| 40        | MOV B，B    | 50          | MOV D，B   |
| 41        | MOV B，C    | 51          | MOV D，C    |
| 42        | MOV B，D    | 52          | MOV D，D    |
| 43        | MOV B，E    | 53          | MOV D，E    |
| 44        | MOV B，H    | 54          | MOV D，H    |
| 45        | MOV B，L    | 55          | MOV D，L    |
| 46        | MOV B，[HL] | 56          | MOV D，[HL] |
| 47        | MOV B，A    | 57          | MOV D，A    |
| 48        | MOV C，B    | 58          | MOV E，B    |
| 49        | MOV C，C    | 59          | MOV E，C    |
| 4A        | MOV C，D    | 5A          | MOV E，D    |
| 4B        | MOV C，E    | 5B          | MOV E，E    |
| 4C        | MOV C，H    | 5C          | MOV E，H    |
| 4D        | MOV C，L    | 5D          | MOV E，L    |
| 4E        | MOV C，[HL] | 5E          | MOV E，[HL] |
| 4F        | MOV C，A    | 5F          | MOV E，A    |

这些指令使用起来非常方便。利用上面的指令可以方便地把一个寄存器存放的数据转移到另一个寄存器。下面我们研究一下以HL寄存器作为操作数的4条指令。

```
MOV B, [HL]
```

前面讲过LDA指令，它可以把单字节的操作数从存储器转移到累加器；LDA操作码后面直接跟着该操作数的16位地址。在上面列出的指令中，MOV指令把直接从存储器转移到V寄存器，但该直接的16位地址却放在HL寄存器对中。HL是怎么得到16位存储器地址的呢？这并不难解决，有很多方法可以做到，比如通过某种计算实现。

```
LDA A, [aaaa]
MOV B, [HL]
```

它们的功能都是把一个字节从内存读入微处理器，但它们寻址存储器的方式并不相同。第一个方式称作直接寻址（direct addressing）；第二个方式称作间接寻址（indexed addressing）。

下面列出了其余32条MOV指令，我们看到HL保存的16位存储器地址也可以作为目标操作数。

| 操作码 | 指令       | 操作码   | 指令       |
| -----  | -----      | -------- | -------    |
| 60     | MOV H，B    | 70       | MOV [HL]，B |
| 61     | MOV H，C    | 71       | MOV [HL]，C |
| 62     | MOV H，D    | 72       | MOV [HL]，D |
| 63     | MOV H，E    | 73       | MOV [HL]，E |
| 64     | MOV H，H    | 74       | MOV [HL]，H |
| 65     | MOV H，L    | 75       | MOV [HL]，L |
| 66     | MOV H，[HL] | 76       | HLT         |
| 67     | MOV H，A    | 77       | MOV [HL]，A |
| 68     | MOV L，B    | 78       | MOV A，B    |
| 69     | MOV L，C    | 79       | MOV A，C    |
| 6A     | MOV L，D    | 7A       | MOV A，D    |
| 6B     | MOV L，E    | 7B       | MOV A，E    |
| 6C     | MOV L，H    | 7C       | MOV A，H    |
| 6D     | MOV L，L    | 7D       | MOV A，L    |
| 6E     | MOV L，[HL] | 7E       | MOV A，[HL] |
| 6F     | MOV L，A    | 7F       | MOV A，A    |

汽油的一些指令如：

```
MOV A, A
```

并不会有执行的操作。

而指令

```
MOV [HL], [HL]
```

是不存在的，实际上，与之对应的指令是HLT(Halt)即停止指令，也就是说该指令的意义是停止。

研究MOV操作码的位模式能更好地了解它，MOV操作码由8位组成：

```
01dddsss
```

其中ddd这3位是目标操作数的代码，sss这3位是源操作数的代码。它们所表示的意义如下：

```
000 = 寄存器B
001 = 寄存器C
010 = 寄存器D
011 = 寄存器E
100 = 寄存器H
101 = 寄存器L
110 = 寄存器HL保存的存储器地址中的内容
111 = 累加器A
```

例如，指令

```
MOV L, E
```

对应的操作码为：

```
01101011
```

用十六进制数可表示为6Bh。这与前面列出的表格是一致的。

可以设想一下，在8080的内部可能是这样的：标记为sss的3位用于8-1数据选择器，标记为ddd的3位用来控制3-8译码器以此确定哪一个寄存器锁存了值。

寄存器B和C也可以组合成16位的寄存器对BC，同样我们还可以用D和E组成寄存器对DE。如果这些寄存器对也包含要读取或保存的字节的存储器地址，则可以用下面的指令实现：

| 操作码 | 指令         | 操作码 | 指令         |
| ------ | ----         | ------ | ----         |
| 02     | STAX [BC], A | 0A     | LDAX A, [BC] |
| 12     | STAX [DE], A | 1A     | LDAX A, [DE] |

另一种类型的传送（Move）指令称作传送立即数（Move Immediate），它的助记符写作MVI。传送立即数指令是一个双字节指令，第一个字节为操作码，第二个是数据。这个单字节数据从存储器转移到某个寄存器，或者转移到存储器中的某个存储单元，该存储单元由HL寄存器对寻址。

| 操作码  |   指令|
| ------- | ------- |
| 06| MVI    B，xx|
| 0E |    MVI C，xx|
| 16 | MVI D，xx|
| 1E |        MVI E，xx|
| 26|MVI      H，xx|
| 2E |        MVI L，xx|
|36 |        MVI [HL]，xx|
|3E|         MVI A，xx|

例如，当指令：

```
MVI    E，37h
```
执行后，寄存器E存放的字节是37h。这就是我们要介绍的第三种寻址方式——立即数寻址（immediate addressing）。

##### 基本运算操作码

下面列出一个操作码集，包括32个操作码，它们能完成4种基本的算术运算，这些运算在第17章设计处理器时我们已经熟悉了，它们是加法（ADD），进位加法（ADC），减法（SUB）和借位减法（SBB）。可以看到，在所有的例子中，累加器始终用于存放其中的一个操作数，同时用来保存计算结果。

| 操作码 | 指令        | 操作码    | 指令        |
| ------ | -----       | --------- | ----        |
| 80     | ADD A，B    | 90        | SUB A，B    |
| 81     | ADD A，C    | 91        | SUB A，C    |
| 82     | ADD A，D    | 92        | SUB A，D    |
| 83     | ADD A，E    | 93        | SUB A，E    |
| 84     | ADD A，H    | 94        | SUB A，H    |
| 85     | ADD A，L    | 95        | SUB A，L    |
| 86     | ADD A，[HL] | 96        | SUB A，[HL] |
| 87     | ADD A，A    | 97        | SUB A，A    |
| 88     | ADC A，B    | 98        | SBB A，B    |
| 89     | ADC A，C    | 99        | SBB A，C    |
| 8A     | ADC A，D    | 9A        | SBB A，D    |
| 8B     | ADC A，E    | 9B        | SBB A，E    |
| 8C     | ADC A，H    | 9C        | SBB A，H    |
| 8D     | ADC A，L    | 9D        | SBB A，L    |
| 8E     | ADC A，[HL] | 9E        | SBB A，[HL] |
| 8F     | ADC A，A    | 9F        | SBB A，A    |

假如累加器A存放的字节是35h，累加器B存放的字节是22h，经过减法运算：

```
SUB A, B
```

累加器中的值变为22h，即两个字节的差。

如果累加器A中的值为35h，寄存器H和L中的值分别是10h和7Ch，而存储器地址107Ch处的字节为4Ah，指令：

```
ADD A, [HL]
```

把累加器中的值（35h）与寄存器对HL寻址（107Ch）存储器得到的数值（4Ah）相加，并把计算结果（7Fh）保存到累加器。

在8080中，使用ADC指令和SBB指令可以对16位数，24位数，32位数甚至更高位的数进行加法，减法运算。例如，假设现在寄存器对BC和DE各自保存了一个16位的数，我们要把这两个数相加，并且把结果保存在寄存器对BC中。具体做法如下：

```
MOV A, C    ;低字节操作
ADD A, E
MOV C, A
MOV A, B    ;高字节操作
ADC A, D
MOV B, A
```
在上面的计算中，用ADD指令对低字节相加，用ADC指令对高字节相加。低字节相加产生的进位会进入高字节的运算中。在这段简短的代码中，我们用到了4个MOV指令，这是因为在8080中只能利用累加器进行加法运算，操作数在累加器和寄存器之间来回地传送，因此在8080的代码中大量使用MOV指令。

##### 标志位

现在我们来讨论8080的标志位（flag）。第17章设计的处理器已经有了CF（进位标志位）和ZF（零标志位）两个标志位，在8080中又新增了3个标志位，包括符号标志位SF，奇偶标志位PF和辅助进位标志位AF。在8080中，用一个专门的8位寄存器来存放所有标志位，改寄存器称为程序状态字（Program Status World，PSW）。不同的指令对标志位有不同的影响，LDA，STA或MOV指令始终都不会影响标志位，而ADD，SUB，ADC以及SBB指令会影响标志位的状态，具体情况如下。

- 如果运算结果的最高位是1，那么符号标志位SF标志位置1，表示该计算结果是负数。
- 如果运算结果为0，则零标志位ZF置0.
- 如果运算结果中“1”的位数是偶数，即具有偶数性（even parity），则奇偶标志位PF置1；反之，如果“1”的位数是奇数，即运算结果具有奇数性（odd parity），则PF置0.由于PF的这个特点，有时会被用来进行简单的错误检查。PF在8080程序中并不常见。
- 进位标志位CF的情况和第17章描述的稍有不同，当ADD和ADC运算产生进位或者SUB和SBB运算不发生借位时，CF都置1.
- 辅助进位标志位AF只有在运算结果的低4位向高4位有进位时才置1.它只用于DAA（Decimal Adjust Accumulator，十进制调整累加器）指令中。

下面的两条会直接影响进位标志位CF。

| 操作码 | 指 令 | 含 义    |
| ------ | ----- | -----    |
| 37     | STC   | 令CF置1  |
| 3F     | CMC   | 令CF取反 |

##### 逻辑运算

第17章设计的计算机可以执行ADD，ADC，SUB和SBB指令（虽然缺乏灵活性），而8080功能更为强大，它还可以执行AND（与），OR（或），XOR（异或）等逻辑运算。不论是算术运算还是逻辑运算，都是由8080处理器的算术逻辑单元（ALU）来完成的。

以下是8080的算术运算和逻辑运算指令。

| 操作码 | 指令        | 操作码 | 指令        |
| ------ | ----        | ------ | ----        |
| A0     | AND A，B    | B0     | OR A，B     |
| A1     | AND A，C    | B1     | OR A，C     |
| A2     | AND A，D    | B2     | OR A，D     |
| A3     | AND A，E    | B3     | OR A，E     |
| A4     | AND A，H    | B4     | OR A，H     |
| A5     | AND A，L    | B5     | OR A，L     |
| A6     | AND A，[HL] | B6     | OR A，[HL]  |
| A7     | AND A，A    | B7     | OR A，A     |
| A8     | XOR A，B    | B8     | CMP A，B    |
| A9     | XOR A，C    | B9     | CMP A，C    |
| AA     | XOR A，D    | BA     | CMP A，D    |
| AB     | XOR A，E    | BB     | CMP A，E    |
| AC     | XOR A，H    | BC     | CMP A，H    |
| AD     | XOR A，L    | BD     | CMP A，L    |
| AE     | XOR A，[HL] | BE     | CMP A，[HL] |
| AF     | XOR A，A    | BF     | CMP A，A    |

AND, XOR和OR都是按位运算（bitwise operation）指令，也就是说对于这些逻辑运算指令，其操作数的每一个对应位都是独立运算的，例如：

```
MVI A, 0Fh
MVI B, 55h
AND A, B
```

保存到累加器的结果将会是05h。假如我们把3条指令换作OR，则最终的结果将会是5Fh；如果换作XOR，则结果会变成了5Ah。

##### CMP指令

CMP（Compare，比较）指令同SUB指令类似，也是把两个数相减，不同之处在于它并不在累加器中保存计算结果，计算的目的是为了设置标志位。这个标志位的值可以告诉我们两个操作数之间的大小关系。例如，我们考虑下面的指令：

```
MVI B, 25h
CMP A, B
```

指令执行后，累加器A中的值并没有变化。改变的是标志位的值，如果A中的值等于25h，则零标志位ZF置1；如果A中的值小于25h，则进位标志位CF置1.

##### 立即数操作

同样的，也可以对立即数进行这8种算术逻辑操作。

| 操作码 | 指令      | 操作码   | 指令      |
| ------ | -------   | -------- | ----      |
| C6     | ADI A，xx | E6       | ANI A，xx |
| CE     | ACI A，xx | EE       | XRI A，xx |
| D6     | SUI A，xx | F6       | ORI A，xx |
| DE     | SBI A，xx | FE       | CPI A，xx |

例如，可以用下面的这条指令来代替上面列出的两条指令：

```
CPI A, 25h
```

##### CMA和DAA

下面是两种特别的8080指令。

| 操作码 | 指令 |
| ------ | ---- |
| 27     | DAA  |
| 2F     | CMA  |

CMA是Complement Accumulator的缩写。它对累加器中的按数位取反，即把0变成1，1变成0.例如，累加器中的数如果是01100101，使用CMA命令后，累加器中的数按位取反，得到10011010。我们还可以使用如下指令对累加器中的数取反：

```
XRI A, FFH
```

前面提到过，DAA是Decimal Adjust Accumulator的缩写，即十进制调整累加器，它可能是8080中最复杂的一条指令。在8080微处理器中专门设计了一个完整的小部件用来执行该指令。

DAA指令提供了一种用二进制码表示十进制数的方法，称为BCD码（binary－coded decimal），程序员可以在该指令的帮助下实现十进制的算术运算。BCD码采用的表示方式为，每4位为一段，每段所能表示数的范围是：0000～1001，对应十进制的0～9.因为1字节有8位故可分割为2个段，因此在BCD码格式下，一个字节可以表示两位十进制数。

假设累加器A存放的是BCD码表示的27h，显然它就对应十进制数的27。同时假设寄存器B存放着BCD码表示的94h。假设执行如下指令：

```
MVI A, 27h
MVI B, 94h
ADD A, B
```

累加器存放的最终结果是BBh，当然，这肯定不是BCD码。因为BCD码中每4位组成的段所能表示的十进制数不会超过9.然而，当我们执行命令：

```
DAA
```

那么累加器最后所保存的值是21h，而且进位标志位CF置1.因为十进制的27与94相加的结果为121.由此可以看到，使用BCD码进行十进制的算术运算是很方便的。

##### 增量和减量操作

在8080程序中，经常会对一个数进行加1或减1操作。在第17章的乘法程序中，为了实现对一个数减1，我们把该数与FFh相加，它是-1的补码。8080提供了专门的指令用来对寄存器或存储器中的数进行加1（称作增量）或减1（称作减量）操作。

| 操作码 | 指令     | 操作码  | 指令     |
| ------ | -----    | ------- | -------- |
| 04     | INR B    | 05      | DCR B    |
| 0C     | INR C    | 0D      | DCR C    |
| 14     | INR D    | 15      | DCR D    |
| 1C     | INR E    | 1D      | DCR E    |
| 24     | INR H    | 25      | DCR H    |
| 2C     | INR L    | 2D      | DCR L    |
| 34     | INR [HL] | 35      | DCR [HL] |
| 3C     | INR A    | 3D      | DCR A    |

INR和DCR都是单字节指令，它们可以影响除CF（Carry Flag）之外的所有标志位。

##### 循环移位指令

8080还包括4个循环移位（Rotate）指令，这些指令可以把累加器中的内容向左或向右移动1位，它们的具体功能如下。

| 操作码 | 指令 | 含义                 |
| ------ | ---- | ----                 |
| 07     | RLC  | 累加器循环左移       |
| 0F     | RRC  | 累加器循环右移       |
| 17     | RAL  | 累加器带进位循环左移 |
| 1F     | RAR  | 累加器带进位循环右移 |

这些指令只对进位标志位CF有影响。

假设累加器中存放的数是A7h，即二进制的10100111.RLC指令使其每一位都向左移一位。最终的结果是，最低位（左端为低位，右端为高位）移出顶端移至尾部成为最高位，这条指令也会影响CF的状态。在这个例子中CF置1，最后的结果为01001111.RRC指令以同样的方式进行右移位操作。如果移位之前的数是10100111，执行RRC之后将变为11010011，同时CF置1.

较之RLC和RRC，RAL和RAR指令的工作方式稍有不同。执行RAL指令时，累加器中的数仍然按位左移，把CF中原来的值移至累加器中数值的最后一位，同时把累加器中数据的原最高位移至CF。例如，假设累加器中移位之前的数是10100111且CF为0，执行RAL指令后，累加器中的数变为01001110而CF变为1.类似的，如果执行的是RAR指令，累加器中的数变为01010011，而CF变为1.

当我们在程序中需要对某个数进行乘2（左移）或除2（右移）运算时，使用移位操作会使运算变得非常简单。


