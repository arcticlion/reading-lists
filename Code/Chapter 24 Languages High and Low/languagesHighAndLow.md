高级语言与低级语言
=================

使用机器码编写程序就如同牙签吃东西，伸出手臂使出较大的力气刺向食物，但每次都只获取到小小的一块，这个过程是辛苦且漫长的。同样的，每个机器码字节所能我完成的工作，是你能想象到的最微小且最简单的工作——从内存获取一个数，之后加在到处理器，再把它与另一个数相加，最终将运算结果保存到内存等——正因为如此，很难想象如何使用这些机器码构成一个完整的程序。

目前为止，至少对于在第22章讨论的原始模型阶段来说，我们已经取得了一定的进步，在那个阶段，我们使用过控制面板上的开关将二进制数据输入到存储器。在第22章中，介绍如何编写一段简单的程序，让我们可以利用键盘将十六进制机器码输入计算机，以及通过视频显示设备来检查这些代码。这种改进固然可去，但仍不是我们的终极目标。

### 汇编语言

前面的章节介绍过，可以使用某些较短的助记符来关联机器码字节，这些助记符包括MOV，ADD，CALL，HLT等，通过这些类似的英文的符号我们可以较方便地引用机器码。通过这些助记符的后面会跟着操作数，这可以进一步指明它所关联的机器码指令的功能。例如8080机器码字节46h，它的功能是令处理器将存储在内存特定地址的字节转移至寄存器B，而该地址由寄存器对HL中的16位数寻址.这个操作可以简单地写作：

```assembly
MOV B, [HL]
```
显然，使用汇编语言编写程序要比使用机器语言简单得多，但微处理器并不能解释汇编语言。在前面得章节中我们已经学习了如何在纸上编写汇编程序，但只有当你确实准备在微处理器上运行汇编程序，才会手工对其进行汇编，这样就可以将汇编语言程序得语句转成了机器语言代码，并把它们输入内存。

当然，我们希望最好由计算机能独自完成语言转换得工作。如果你得8080计算机正在运行CP/M操作系统，而且你已经拥有了所有必须得工作，那就再好不好了，因为下面我们将介绍其工作原理。

第一步，建立一个文本文件，并将汇编语言程序输入到该文本文件中。这项工作可以使用CP/M的应用程序ED.COM来完成。该程序是一个可以用来创建，修改文本文件的编辑器。假设你把该文本文件命名为PROGRAM1.ASM,其中ASM是文件类型，用来指明该文本文件de内容是由汇编语言程序组成。这个文件的内容如下：

```assembly
      ORG 0100h
      LXI DE, Text
      MVI C, 9
      CALL 5
      RET
Text: DB 'Hello!$'
      END
```
这个文件中有两条语句我们从未接触过。第一条语句是ORG（origin），它不与任何8080指令对应，其功能是用来指明下面语句的地址从0100h地址处开始。如前所述，该地址是CP/M将程序装入内存的起始地址。


第二条语句是LXI（Load Extended Immediate）指令，其功能是将一个16位数加载到寄存器DE。本例中，该16位数使用标记Text提供的。该标记在程序底端的附近，位于DB（Data Byte）语句之前。DB语句我们也是第一次遇到，其后可以跟着一些字节，这些字节以逗号分隔或者用单引号括起来（如本例）。

MVI（Move Immediate）语句将数值9转移到寄存器C。

CALL 5语句实现CP/M的函数调用功能。函数5的作用是：显示以寄存器对DE给出的地址为起始处的字符串，直到遇到$结束（可以看出，在程序的结尾处使用了美元符号“$"作为文本的结束标记，并把控制权交还给CP/M（实际上，这只是结束CP/M程序的方法之一）。

END语句用来指明汇编语言文件已经结束。

现在我们已经有了一个包含7行语句的文本文件，下一步要做的就是对其进行汇编，即将其转换成机器语言代码。以前这项工作是通过手工完成的，但现在我们的机器运行的是CP/M系统，可以利用CP/M中一个叫做ASM.COM的模块来完成这项工作。该模块是CP/M的汇编器（assembler）。可以在CP/M命令行中使用下面的语句运行ASM.COM文件：

```
ASM PROGRAM1.ASM
```
ASM对PROGRAM1.ASM文件进行汇编，产生一个名为PROGRAM1.COM的新文件，PROGRAM1.COM包含了与我们编写的汇编程序相对应的机器码（实际上，该过程还包含另一个步骤，但在该操作中并不很重要）。现在就可以使用CP/M的命令行来运行PROGRAM1.COM文件，程序运行的结果是显示字符串“Hello!"然后结束。

PROGRAM1.COM文件包含以下16个字节：

```
11 09 01 OE 09 CD 05 00 C9 48 65 6C 6C 6F 21 24
```
开始的3个字节是LXI指令，其后的两个字节是MVI指令，接下来的三个字节是CALL指令，紧随其后的一个字节是RET指令，最后的7个字节是ASCII码，包括5个字母“Hello”，感叹号“！”以及美元符号“$".

像ASM.COm这样的汇编器所做的工作是：读取一个汇编文件（source-code, 通常称作源代码文件），将其转换得到一个包含机器码的文件——可执行（executable file）。从宏观的角度来看，汇编器是非常简单的，因为构成汇编语言的助记符和机器码之间是一一对应的。汇编器拥有一张包括所有可能助记符及其参数的表，它逐行读取汇编语言程序，把每一行都分解成为助记符和参数，然后把这些短小的单词和字符与表中的内容匹配。通过这种匹配的过程，每一个语句都会找到与其对应的机器码指令。

> 注意，汇编器如何直到LXI指令必须将寄存器DE的值设置为地址0109h（Text的地址）。如果LXI指令本身被存放在地址0100h处（CP/M将程序加载至内存开始运行时的起始地址），而0109h则是Text字符串的起始地址。一般来说，程序员在使用汇编器时有很多方便之处，其中一点就是不需要关心汇编程序各部分在内存中的存放地址。

第一个编写汇编器的人需要手工对程序汇编。如果要为机器写一个新的汇编器（或者对其修改），则可以使用汇编语言编写该程序，然后使用原有的汇编器对其汇编。一旦新的汇编器通过汇编，则它也就可以对自身进行汇编。

每当一种新的微处理器面世，就需要为其编写新的汇编器。然而，新的汇编器可以在已有的计算机上编写，并利用其汇编器进行汇编。这种方式成为交叉汇编（cross-assembler),即利用计算机A的汇编器对运行在计算机B上的程序汇编。

虽然汇编器的引入消除了汇编语言变化成中重复性的劳动部分（即手动汇编部分），但汇编语言仍然存在两个主要问题。第一个问题（也许你已经意识到了），使用汇编语言编程非常乏味，因为这是在微处理器芯片级的编程，因此不得不考虑每一个微小的细节。

汇编语言存在的第二个问题是不可“移植”（protable）。如果你为Intel 8080写了一个汇编语言程序，则该程序不能在Motorola 6800上运行，你必须在6800上重写一个相同功能的汇编语言程序。编写类似程序的过程也许没有编写第一个程序那么困难，因为你已经解决了程序组织和算法问题，但仍然还有很多工作要做。


