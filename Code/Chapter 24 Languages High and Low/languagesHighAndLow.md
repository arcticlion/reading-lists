高级语言与低级语言
=================

使用机器码编写程序就如同牙签吃东西，伸出手臂使出较大的力气刺向食物，但每次都只获取到小小的一块，这个过程是辛苦且漫长的。同样的，每个机器码字节所能我完成的工作，是你能想象到的最微小且最简单的工作——从内存获取一个数，之后加在到处理器，再把它与另一个数相加，最终将运算结果保存到内存等——正因为如此，很难想象如何使用这些机器码构成一个完整的程序。

目前为止，至少对于在第22章讨论的原始模型阶段来说，我们已经取得了一定的进步，在那个阶段，我们使用过控制面板上的开关将二进制数据输入到存储器。在第22章中，介绍如何编写一段简单的程序，让我们可以利用键盘将十六进制机器码输入计算机，以及通过视频显示设备来检查这些代码。这种改进固然可去，但仍不是我们的终极目标。

### 汇编语言

前面的章节介绍过，可以使用某些较短的助记符来关联机器码字节，这些助记符包括MOV，ADD，CALL，HLT等，通过这些类似的英文的符号我们可以较方便地引用机器码。通过这些助记符的后面会跟着操作数，这可以进一步指明它所关联的机器码指令的功能。例如8080机器码字节46h，它的功能是令处理器将存储在内存特定地址的字节转移至寄存器B，而该地址由寄存器对HL中的16位数寻址.这个操作可以简单地写作：

```assembly
MOV B, [HL]
```
显然，使用汇编语言编写程序要比使用机器语言简单得多，但微处理器并不能解释汇编语言。在前面得章节中我们已经学习了如何在纸上编写汇编程序，但只有当你确实准备在微处理器上运行汇编程序，才会手工对其进行汇编，这样就可以将汇编语言程序得语句转成了机器语言代码，并把它们输入内存。

当然，我们希望最好由计算机能独自完成语言转换得工作。如果你得8080计算机正在运行CP/M操作系统，而且你已经拥有了所有必须得工作，那就再好不好了，因为下面我们将介绍其工作原理。

第一步，建立一个文本文件，并将汇编语言程序输入到该文本文件中。这项工作可以使用CP/M的应用程序ED.COM来完成。该程序是一个可以用来创建，修改文本文件的编辑器。假设你把该文本文件命名为PROGRAM1.ASM,其中ASM是文件类型，用来指明该文本文件de内容是由汇编语言程序组成。这个文件的内容如下：

```assembly
      ORG 0100h
      LXI DE, Text
      MVI C, 9
      CALL 5
      RET
Text: DB 'Hello!$'
      END
```
这个文件中有两条语句我们从未接触过。第一条语句是ORG（origin），它不与任何8080指令对应，其功能是用来指明下面语句的地址从0100h地址处开始。如前所述，该地址是CP/M将程序装入内存的起始地址。


第二条语句是LXI（Load Extended Immediate）指令，其功能是将一个16位数加载到寄存器DE。本例中，该16位数使用标记Text提供的。该标记在程序底端的附近，位于DB（Data Byte）语句之前。DB语句我们也是第一次遇到，其后可以跟着一些字节，这些字节以逗号分隔或者用单引号括起来（如本例）。

MVI（Move Immediate）语句将数值9转移到寄存器C。

CALL 5语句实现CP/M的函数调用功能。函数5的作用是：显示以寄存器对DE给出的地址为起始处的字符串，直到遇到$结束（可以看出，在程序的结尾处使用了美元符号“$"作为文本的结束标记，并把控制权交还给CP/M（实际上，这只是结束CP/M程序的方法之一）。

END语句用来指明汇编语言文件已经结束。

现在我们已经有了一个包含7行语句的文本文件，下一步要做的就是对其进行汇编，即将其转换成机器语言代码。以前这项工作是通过手工完成的，但现在我们的机器运行的是CP/M系统，可以利用CP/M中一个叫做ASM.COM的模块来完成这项工作。该模块是CP/M的汇编器（assembler）。可以在CP/M命令行中使用下面的语句运行ASM.COM文件：

```
ASM PROGRAM1.ASM
```
ASM对PROGRAM1.ASM文件进行汇编，产生一个名为PROGRAM1.COM的新文件，PROGRAM1.COM包含了与我们编写的汇编程序相对应的机器码（实际上，该过程还包含另一个步骤，但在该操作中并不很重要）。现在就可以使用CP/M的命令行来运行PROGRAM1.COM文件，程序运行的结果是显示字符串“Hello!"然后结束。

PROGRAM1.COM文件包含以下16个字节：

```
11 09 01 OE 09 CD 05 00 C9 48 65 6C 6C 6F 21 24
```
开始的3个字节是LXI指令，其后的两个字节是MVI指令，接下来的三个字节是CALL指令，紧随其后的一个字节是RET指令，最后的7个字节是ASCII码，包括5个字母“Hello”，感叹号“！”以及美元符号“$".

像ASM.COm这样的汇编器所做的工作是：读取一个汇编文件（source-code, 通常称作源代码文件），将其转换得到一个包含机器码的文件——可执行（executable file）。从宏观的角度来看，汇编器是非常简单的，因为构成汇编语言的助记符和机器码之间是一一对应的。汇编器拥有一张包括所有可能助记符及其参数的表，它逐行读取汇编语言程序，把每一行都分解成为助记符和参数，然后把这些短小的单词和字符与表中的内容匹配。通过这种匹配的过程，每一个语句都会找到与其对应的机器码指令。

> 注意，汇编器如何直到LXI指令必须将寄存器DE的值设置为地址0109h（Text的地址）。如果LXI指令本身被存放在地址0100h处（CP/M将程序加载至内存开始运行时的起始地址），而0109h则是Text字符串的起始地址。一般来说，程序员在使用汇编器时有很多方便之处，其中一点就是不需要关心汇编程序各部分在内存中的存放地址。

第一个编写汇编器的人需要手工对程序汇编。如果要为机器写一个新的汇编器（或者对其修改），则可以使用汇编语言编写该程序，然后使用原有的汇编器对其汇编。一旦新的汇编器通过汇编，则它也就可以对自身进行汇编。

每当一种新的微处理器面世，就需要为其编写新的汇编器。然而，新的汇编器可以在已有的计算机上编写，并利用其汇编器进行汇编。这种方式成为交叉汇编（cross-assembler),即利用计算机A的汇编器对运行在计算机B上的程序汇编。

虽然汇编器的引入消除了汇编语言变化成中重复性的劳动部分（即手动汇编部分），但汇编语言仍然存在两个主要问题。第一个问题（也许你已经意识到了），使用汇编语言编程非常乏味，因为这是在微处理器芯片级的编程，因此不得不考虑每一个微小的细节。

汇编语言存在的第二个问题是不可“移植”（protable）。如果你为Intel 8080写了一个汇编语言程序，则该程序不能在Motorola 6800上运行，你必须在6800上重写一个相同功能的汇编语言程序。编写类似程序的过程也许没有编写第一个程序那么困难，因为你已经解决了程序组织和算法问题，但仍然还有很多工作要做。

### 高级程序设计语言

上一章介绍了现代微处理器集成浮点运算机器码的原理。不可否认，这已经为我们带来了很大的便利，但仍不能令人满意。一种更好的方式是：完全放弃那些实现每个基本操作的机器码指令，这些指令与处理器相关，因而导致程序缺乏移植性。我们采用的替代策略是使用一些经典的数学表达式来描述复杂的数学运算。下面是一个表达式的例子：

```
A x Sin(2xPI+B)/C
```
上式中A，B，C代表数字，而PI＝3.14159.

这看起来不错，为什么不动手尝试以下呢？假设在某个文本文件中有这样一个表达式，那么我们可以尝试编写一个汇编语言程序来读取该文本文件，并将其中的数学表达式转换为机器码。

如果只需要计算一次该表达式，那么可以手工计算或借助计算器来完成。如果需要对A，B，C取不同的值多次计算该表达式，那么你可能要考虑使用计算机来完成这些计算。因此，代数表达式不会孤立地出现，必须考虑其前后的语句，这些语句使表达式对不同的值进行运算。

现在你所创建的东西已经触及所谓的高级程序设计语言（high-level programming language).我们一直在介绍的汇编语言称作低级语言（low-level programming language), 因为它与计算机硬件的关系相当紧密。尽管除了汇编语言以外的其他程序设计语言都可以称为“高级语言”，但它们之间还是有高低之分的。

人类语言通常都是经历了千百年复杂的互相影响，偶然演变以及不断吐故纳新才形成的，就算一些人工语言如世界语（Esperanto），也处处显露出与现实语言的渊源。但高级程序设计语言是经过深思熟虑的设计，更加概念化的语言。设计程序语言所面临的一大挑战就是：如何让语言更具吸引力。因为语言定义了人们向计算机传送指令的方式，只有更易用的方式才能让人们对语言产生兴趣。据1993年的一项估算，从1950年到1993年大约有1000多种高级程序设计语言被发明出来并被应用。

然而，仅仅定义（define）高级语言，包括定义语言的语法（syntax）来表达该语言可以描述的一切事物，还远远不够；我们还需要为其编写一个编译器（compiler），编译器可以将高级语言的程序语句转换为机器码指令。同汇编器类似，编译器也是逐字逐句地读取源文件并将其分解成短语，符号和数字的，而实现过程要比汇编器更加复杂。从某些方面来看，编译器相对简单，因为汇编语言的语句和机器码是一一对应的。而一般的高级语言却不具备这种对应关系，编译器通常必须把一条语句转换多个机器码指令。编译器的编写非常复杂，许多书都是用全部的篇幅来讲解如何设计和构造编译器。

当然，任何事物都具有两面性，高级语言也不例外，它有很多优势但也存在不少缺陷。高级语言最基本的有点在于它比汇编语言更易于学习而且更容易编写程序，用高级语言编写的程序通常更加清晰简明——与汇编语言不同，高级语言通常不依赖于特定的处理器，因此它们通常具有良好的可移植性。因为这种特点，使用高级语言的程序员不再需要关心最终运行程序的计算机的底层结构。当然，如果要在不同类型处理器上运行程序，则需要用处理器对应的编译器将程序转换成对应的机器码。因此，最后生成的可执行文件仍然只适用于特定的处理器。

另一方面，有一种普遍现象：一个优秀的汇编程序员所编写的程序比编译器所产生的代码更加有效率。也就是说 ，从高级语言程序生成的可执行程序比相同功能的汇编语言更大，并且运行速度更慢（但从近年的发展来看，这种差别已不再明显，因为微处理器变得更加复杂，而且编译器在优化代码方面也更加成熟）。

此外，虽然高级语言提高了处理器的易用性，但并没有让其变得更强大。微处理器的任何一个功能都可以通过汇编语言实现，因此汇编语言可以高度利用处理器的功能。因为高级语言必须转换成机器码，所有它只会降低微处理器的能力。事实上，如果某种高级语言具有真正意义的可移植性，那么它将不能使用某些处理器的特有功能。

例如，许多微处理器都有移位指令。如前所述，这些指令能将累加器中的字节的每一位向左或向右移动。但事实上，几乎没有哪一种高级语言包含这种操作。如果再程序中需要进行移位操作，则必须通常乘2或除2来模拟该过程（则并不是什么坏事：事实上，许多现代编译器都是利用处理器的移位指令来实现乘以2或除以2的幂的）。除此之外，许多高级语言也不包括按位逻辑运算。

在早期的家用计算机中，大部分应用程序都是用汇编语言写的，而现在除了一些特殊的应用场合之外，汇编语言已经很少使用了。而今处理器引入了一些新的硬件，可以实现流水线技术——同时有若干个指令码渐次执行——这使得汇编语言变得更加复杂且不易处理。与此同时，编译器却变得更加成熟，越来越多的程序开始使用高级语言来编写。现代计算机大容量的存储器也作为一个重要的角色，推动了这种趋势：程序员不再局限于编写运行在小内存和小磁盘上的程序。

早期的计算机设计者都曾尝试用数学符号来描述问题，但公认的第一个真正可以工作的编译器是A-0,它是为UNIVAC开发的编译器，于1952年由雷顿兰德公司（Remington-Rand)的格瑞斯·穆雷·霍泊（Grace Murray Hopper，1906-1992）开发完成。Hopper博士早期计算机研究工作始于1944年，那时她效力于霍华德·艾肯（Howard Aiken），主要研究Mark I。在她八十多岁的时候，仍然孜孜不倦地在计算机界工作，当时她在DEC（Digital Equipment Corporation）公司从事公关事务。
