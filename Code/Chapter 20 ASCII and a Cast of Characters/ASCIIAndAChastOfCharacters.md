ASCII码和字符转换
================

数字计算机中的存储器唯一可以存储的是比特，因此如果要想在计算机上处理信息，就必须把它们按位存储。通过之前的学习，我们已经掌握了如何用比特来表示数字和机器码。现在我们面临的一大挑战是如何用它来存储文本。

### 字符编码集与字符编码

为了将文本表示数字形式，我们需要构建一种系统来为每一个字母赋予一个唯一的编码。数字和标点符号也算做文本的一种形式，所以它们也必须拥有自己的编码。简而言之，所有由符号所表示的字母和数字（Alphanumeric）都需要编码。具有这种功能的系统被称为字符编码集（Coded Character Set），系统内的每个独立编码称为字符编码（Character Codes）。

### 确定编码的比特数

首先，我们要确定构成这些编码究竟需要多少比特。

极力阐述一个重要的观点，那就是文本与其印刷在纸上时采用的二维码排版格式是两码事。文本可以看成是一维的由字母，数字和标点符号组成的数据流。

莫尔斯码和布莱叶盲文能运用到计算机中吗？难上加难。

莫尔斯码是变量自适应长度（Variable-Width)编码，非常适合电报系统，但并不适用于计算机。另外也不区分大小写。

布莱叶盲文固定宽度的特点非常适合计算机使用。类似的拥有固定宽度的编码是莫里编码。

1874年由法国电报服务公司（French Telegraph Service）职员埃米尔∙波多（Emile Baudot）发明了可以打印的电报机，划时代的波多电传码也应运产生。这种编码十分“经济划算”，每一个文本字符都采用5位编码。他的编码1877年被服务公司采纳，后来由DonaldMurray修改并在1931年被CCITT，即现在的国际电联(ITU)标准化。该编码的正式名称是国际电报字母表NO.2或ITA-2，在美国通常称为波多印字电报制（Baudot），尽管更科学的叫法为莫里（Murray）编码。

随着20世纪的到来，Baudot被广泛应用于电传打字机（teletypewrite）。Baudot 电传打字机配备了一个输入键盘，这款键盘有些像打字机，但只有30个键和一个空格键。电传打字机键盘上的每一个键实际上都起到了转换器的作用，它负责产生二进制编码并且通过输出电缆逐位传输出去。电传打字机也具备打印功能，通过输入电缆读取编码，触发电磁铁，从而将字符打印在纸上。

由于Baudot对每个字符采用5位编码，整个系统由32个编码所组成，这些编码的十六进制取值范围从00h到1Fh。下表给出了32个不同编码的十六进制形式及其所对应的字母表中的字符。

| 十六进制码 | Baudet字符           | 十六进制码 | Baudet字符            |
| ---------- | ----------           | ---------- | ----------            |
| 00         |                      | 10         | E                     |
| 01         | T                    | 11         | Z                     |
| 02         | CarriageReturn(回车) | 12         | D                     |
| 03         | O                    | 13         | B                     |
| 04         | Space(空格)          | 14         | S                     |
| 05         | H                    | 15         | Y                     |
| 06         | N                    | 16         | F                     |
| 07         | M                    | 17         | X                     |
| 08         | LineFeed(换行)       | 18         | A                     |
| 09         | L                    | 19         | W                     |
| 0A         | R                    | 1A         | J                     |
| 0B         | G                    | 1B         | FigureShift(数字转义) |
| 0C         | I                    | 1C         | U                     |
| 0D         | P                    | 1D         | Q                     |
| 0E         | C                    | 1E         | K                     |
| 0F         | V                    | 1F         | LetterShift(字符转义) |

编码00h被保留下来，没有指派给任何值。剩下的31个编码中，字母表中的字符占了26个，其余5个用来调整格式，如上表中的楷体排版的语句所示。

编码04h用来表示空格，通常用于分隔单词。编码02h和08h表示的是回车和换行。这些都是电传打字机中的专业术语。当使用电传打字机上打字，一旦到了一行的末尾时，我们通常会按下一个操作杆或按钮。这个操作其实包括两个动作：第一个动作是，使打印机的滑架回到起始位置，这样打印下一行时可以从纸的最左边开始，这就是回车。第二个动作是，将打印机的滑架移至正在使用中的位置的下一行，这就是换行。在Baudot编码系统中，这两个编码由专门的按键产生。Baudot电传打字机在打印的时候会响应这两个编码以完成相应的操作。

Baudot系统里怎么没有数字和标点符号呢？其实这是因为编码1Bh中暗藏玄机，它的实际作用是数字转义（Figure Shift）。数字转义编码后的所有的编码都会被解释为数字或标点符号，直到遇到字符转义编码（1Fh），一切就又被解释为字符。下表展示了十六进制编码以及所对应的数字和标点符号。

| 十六进制码 | Baudot字符     | 十六进制码 | Baudot字符  |
| ---------  | ----------     | ---------- | ----------  |
| 00         |                | 10         | 3           |
| 01         | 5              | 11         | +           |
| 02         | CarriageReturn | 12         | WhoAreYou?  |
| 03         | 9              | 13         | ?           |
| 04         | Space          | 14         | ‘           |
| 05         | #              | 15         | 6           |
| 06         | ，             | 16         | $           |
| 07         | 。             | 17         | /           |
| 08         | LineFeed       | 18         | -           |
| 09         | )              | 19         | 2           |
| 0A         | 4              | 1A         | Bel(响铃)   |
| 0B         | &              | 1B         | FigureShift |
| 0C         | 8              | 1C         | 7           |
| 0D         | 0              | 1D         | 1           |
| 0E         | ：             | 1E         | (           |
| 0F         | =              | 1F         | LetterShift |

表中列出的是这几个编码是美国的使用时的含义。响铃编码令电传打字机发出清脆的铃声。“Who Are You”编码用来让打字员激活身份识别机制。

像莫尔斯码一样，这种5位的编码并没有提供区分大，小写的方法。下面这个橘子：

```
I SPEND $25 TODAY.
```

表示成编码的十六进制数据流就是：

```
0C 04 14 0D 10 06 12 04 1B 16 19 01 1F 04 01 03 12 18 15 1B 07 02 08
```

> 请注意三个转义码的使用：1Bh出现在数字之前，1Fh出现在数字之后，而数字结束之后又出现了1Bh。这一行编码以回车，换行符结尾。

问题出来了，如果把相同的数据流再一次输入到电传打印机，情况就大不一样了。

如下所示：

```
I  SPENT  $25  TODAY.

8 ‘03,5  $25  TODAY.
```

> 这是由于在接受第二行编码之前打印机接受到的最后一个转义码是数字转义码，所以当遇到第二行开头几个编码时，打印机将它们解释为数字。

这种问题产生的根源就是采用了转义码。尽管Baudot电传码是简单实用的编码，但是我们更希望采用能唯一表示字符，数字及标点符号的编码方案，如果能区分大小写就更好了。

如果想直到比Baudot更好用的编码系统中一个编码需要多少比特，我们需要做几个小加法：所有的大小写字母加起来共需52隔编码，数字10个编码，加起来有62个，再加上标点符号，数量超过了64个，也就是说，一个编码至少需要64比特。但无论如何字符数应该不超过128个，也就是说编码长度不会超过7位。

所以，答案就是7.再采用7位编码时，不需要转义字符，而且可以区分字母的大小写。

### ASCII

这些字符编码是什么样子的呢？其实我们可以随意编码。但是随意的编码并不太合适。我们需要所有人都遵循并使用统一化的编码，计算机的存在才有意义。这样以来，使用不同方法制造出的计算机之间就可以互相兼容，甚至可以互相交流文本信息。

幸运的是，我们已经有了这样一个标准，即美国信息交换标准代码(American Standard Code for Information Interchange)，简写为ASCII码。它1967年正式公布，此后一直是计算机工业界最为重要的标准。除了一个大的例外（在后面讲到），可以肯定的是，无论什么时候处理文本，总会以某种方式涉及到ASCII码。

ASCII码是7位编码，它的二进制取值范围为0000000～1111111，对应于十六进制就是00h～7Fh。现在我们一起来讨论下ASCII码，但我们不建议从开始学起，因为相对于后面的编码，前32个编码理解起来还有一点难度。所以我们从第2组32个编码开始学习，它包括标点符号和10个数字。下面列出了这32个字符及相应的十六进制编码。

| 十六进制码 | ASCII字符 | 十六进制码 | ASCII字符 |
| ---------- | --------- | ---------- | --------- |
| 20         | space     | 30         | 0         |
| 21         | ！        | 31         | 1         |
| 22         | “         | 32         | 2         |
| 23         | #         | 33         | 3         |
| 24         | $         | 34         | 4         |
| 25         | %         | 35         | 5         |
| 26         | &         | 36         | 6         |
| 27         | ‘         | 37         | 7         |
| 28         | (         | 38         | 8         |
| 29         | )         | 39         | 9         |
| 2A         | *         | 3A         | :         |
| 2B         | +         | 3B         | ;         |
| 2C         | ,         | 3C         | <         |
| 2D         | -         | D          | =         |
| 2E         | .         | 3E         | >         |
| 2F         | /         | 3F         | ?         |

值得注意的是20h代表空格符，它的作用是将单词或句子隔开。

接下来的32个编码是大写字母和一些附加的标点符号的编码。除了@符号和下画线之外，其余的符号很难在打字机上找到。

| 十六进制码   | ASCII字符      | 十六进制码     | ASCII字符    |
| ------------ | -------------- | -------------- | ------------ |
| 40           | @              | 50             | P            |
| 41           | A              | 51             | Q            |
| 42           | B              | 52             | R            |
| 43           | C              | 53             | S            |
| 44           | D              | 54             | T            |
| 45           | E              | 55             | U            |
| 46           | F              | 56             | V            |
| 47           | G              | 57             | W            |
| 48           | H              | 58             | X            |
| 49           | I              | 59             | Y            |
| 4A           | J              | 5A             | Z            |
| 4B           | K              | 5B             | [            |
| 4C           | L              | 5C             | \            |
| 4D           | M              | 5D             | ]            |
| 4E           | N              | 5E             | ^            |
| 4F           | O              | 5F             | -            |


接下来的32个编码是所有小写字母和一些附加的标点符号及其对应的十六进制编码，这些字符也很在打字机上出现。

| 十六进制码 | ASCII字符  | 十六进制码 | ASCII字符 |
| ---------- | ---------- | ---------- | --------- |
| 60         | `          | 70         | p         |
| 61         | a          | 71         | q         |
| 62         | b          | 72         | r         |
| 63         | c          | 73         | s         |
| 64         | d          | 74         | t         |
| 65         | e          | 75         | u         |
| 66         | f          | 76         | v         |
| 67         | g          | 77         | w         |
| 68         | h          | 78         | x         |
| 69         | i          | 79         | y         |
| 6A         | j          | 7A         | z         |
| 6B         | k          | 7B         | {         |
| 6C         | l          | 7C         | |         |
| 6D         | m          | 7D         | }         |
| 6E         | n          | 7E         | ~         |
| 6F         | o          |

> 注意，表的最后不包括7Fh及其对应的字符。如果你统计一下，就会发现这三张表共涵盖了95个字符。由于ASCII码的编码长度为7位，所以最多可以表示128个编码，这样算下来还剩33个编码可用。下面我们通过几个简单的例子学习一下编码。

像这样一个字符串：

```
Hello, you!
```

转换成ASCII码，用十六进制表示如下：

```
48  65  6C  6C  6F  2C  20  79  6F  75  21
```

这段编码中，除了普通的字符，逗号（编码2C），空格（编码20）和感叹号（编码21）容易遗漏，需要额外注意。

我们再来看一个例子：

```
I am 12 years old.
```

它用ASCII码表示为：

```
49  20  61  6D  20  31  32  20  79  65  61  72  73  20  6F  6C  64  2E
```

有意思的是数字12的表示方法。在这段编码串中，它被表示成十六进制数31h和32h，也就是数字1和2的ASCII码的组合。当数字12以文本流的身份出现时，不应该用十六进制码01h和02h，或者BCD码12h，或者0Ch来表示。因为这些编码在ASCII码中表示其他的意思。

### 字符转换

在ASCII码中，一个大写字母与其对应应的小写字母的ASCII码值相差20h。这种规律大大简化了程序代码的编写，例如一段将特定的字符串变成大写的程序。假设有一个字符串存放在内存的某个区域，每个字符占据一个字节。下面是一段8080子程序，初始状态下字符串的首地址存放在寄存器HL中；寄存器C存放字符串的长度，也就是字符的个数。

```
Capitalize: MOV A, C    ; c表示剩余的字符数
            CPI A, 00h  ; 与0进行比较
            JZ AllDone  ; 如果剩余的字符数为0，程序结束
            MOV A, [HL] ; 取得下一个字符
            CPI A, 61h  ; 判断A代表的字符的ASCII码是否比`a'小
            JC SkipIt   ; 如果比`a'小，就跳过
            CPI A, 78h  ; 判断是否比`z'大
            JNC SkipIt  ; 如果是，则跳过
            SBI A, 20h  ; 判断是否小写，如果是，则减20h
            MOV [HL], A ; 保存修改过的字符
SkipIt:     INX HL      ; 指向下一个字符
            DCR C       ; 计数器减一
            JMP Capitalize; 返回到程序起始处
AllDone:    RET
```

还有另外一种方法也可以将小写字母减去20h而转换成大写字母，如下所示:

```
ANI A, DFh
``

ANI指令（AND Immediate）用来"与"一个立即数。在上面这个例子中，累加器的数值与DFh执行“按位与”操作，其中DFh转换成二进制数就是11011111.“按位与”操作就是把两个数分别转换成二进制，然后将对应的位进行“与”操作。这个例子中，除了自左向右数的第3位被置成0外，A中的其他位均被保留。通过将这一位设置为0，我们实现了将小写字母的ASCII码转换成大写字母的目的。


